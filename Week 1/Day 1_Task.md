# Day 1 Task 
🖥️Running the MUX Simulation
# Let’s go step by step on how you go from RTL code (good_mux.v) to a synthesized netlist using a tool like Yosys.
Step 1: Write RTL Code

Step 2: Prepare a Synthesis Script

Step 3: Choose a Target Library

Step 4: Run Synthesis
```
RTL Code → Simulation → Synthesis Script + Library → Yosys → Gate-Level Netlist 
```

🔀 What is a Multiplexer (MUX)?

A Multiplexer (MUX) is a combinational digital circuit that selects one of several input signals and forwards it to a single output line.

It acts like a digital switch.

The selection of which input is passed to the output is controlled by select (sel) lines.

# 💡 Why is MUX important?

Used in processors (CPUs) to select data paths.

Helps in decision-making circuits.

Reduces hardware by allowing multiple inputs to share one output channel.

# 🔧 Steps Taken

1. Created good_mux.v with RTL design.

2. Wrote a testbench tb_good_mux.v to apply different inputs and sel.

3. Compiled and ran the design using Icarus Verilog (iverilog).

4. Viewed output waveforms in GTKWave.

# What is RTL?

RTL (Register Transfer Level) is a way of describing digital circuits in terms of data flow between registers and the logic operations performed on that data.

RTL code
```
module good_mux (input i0 ,
 input i1 ,
input sel ,
output reg y);

always @ (*)
begin
	if(sel)
		y <= i1;
	else 
		y <= i0;
end
endmodule
```

📝 Explanation

Module Name: good_mux

Inputs:
```
i0 → first data input

i1 → second data input

sel → selection line (control signal)
```
Output:
```
y → output chosen based on sel
```
🔧 Logic:
```
If sel = 0, the output y = i0.

If sel = 1, the output y = i1.
```
This is the standard behavior of a 2-to-1 multiplexer (MUX), which acts like a switch to select one of two inputs.


# What is a Testbench (TB)?

A Testbench (TB) is a piece of code written in an HDL (like Verilog/SystemVerilog) that is not part of the final hardware but is used to verify the functionality of your design (DUT – Device Under Test).

Testbench
```
`timescale 1ns / 1ps
module tb_good_mux;
	// Inputs
	reg i0,i1,sel;
	// Outputs
	wire y;

        // Instantiate the Unit Under Test (UUT)
	good_mux uut (
		.sel(sel),
		.i0(i0),
		.i1(i1),
		.y(y)
	);

	initial begin
	$dumpfile("tb_good_mux.vcd");
	$dumpvars(0,tb_good_mux);
	// Initialize Inputs
	sel = 0;
	i0 = 0;
	i1 = 0;
	#300 $finish;
	end

always #75 sel = ~sel;
always #10 i0 = ~i0;
always #55 i1 = ~i1;
endmodule
```
📜 Commands Used
Compile the mux with testbench
  ```
iverilog -o good_mux_tb good_mux.v tb_good_mux.v
```
Run the simulation
  ```
./a.out good_mux_tb
```
Open the waveform in GTKWave
  ```
gtkwave dump.vcd
```
<img width="1920" height="909" alt="gtkwave good_mux" src="https://github.com/user-attachments/assets/aea8407d-b62e-4d26-97d5-b2816a9ddf72" />

✅ Result
```
When sel = 0 → y = i0

When sel = 1 → y = i1
```
# Task 2 📁 Library

📁 What is Library?

In the context of digital design and Verilog, a library is essentially a collection of predefined components or modules that you can use in your design, instead of writing everything from scratch.

A library contains cells or modules like:

Logic gates: AND, OR, NAND, NOR

Flip-flops: DFF, TFF

Multiplexers, adders, decoders, etc.

These cells are usually optimized for a specific technology (like 130nm, 65nm) so that when you synthesize your design, the tool can map your logic efficiently to the real hardware.

```sky130_fd_sc_hd_mux2_1```is a library cell from the SkyWater 130nm standard cell library.

Yosys replaced your original Verilog good_mux logic with this optimized hardware implementation.

Why Libraries Are Useful

Time-saving – You don’t need to design gates manually.

Optimized – The library cells are designed for area, speed, and power.

Technology-specific – Makes it easier to target a real chip process.

# Task3 🛠️Synthesis

🛠️ What is Synthesis?

Synthesis is the process of converting your high-level Verilog code (RTL) into a gate-level netlist, which is a structural description of your circuit using basic logic gates. The output of this process is a new Verilog file that represents the synthesized circuit.

📜 Commands Used

Read the Verilog design file
```
read_verilog good_mux.v
```
Perform generic synthesis steps
```
synth -top good_mux
```
Write the synthesized netlist to a new file
```
write_verilog good_mux_netlist.v
```
Generated by Yosys 0.9
```
module good_mux(i0, i1, sel, y);
  wire 0;
  wire 1;
  wire 2;
  wire 3;
  input i0;
  input i1;
  input sel;
  output y;
  sky130_fd_sc_hd_mux2_1 _4 (
    .A0(0),
    .A1(1),
    .S(2),
    .X(3)
  );
  assign 0 = i0;
  assign 1 = i1;
  assign 2 = sel;
  assign y = 3;
endmodule
```
Run 
```
show
```
<img width="1920" height="909" alt="Synthesis good_mux" src="https://github.com/user-attachments/assets/73ffdb7d-0de0-4ffc-a186-788b54c2a3de" />
