# Day 1 Task 
ğŸ–¥ï¸Running the MUX Simulation
# Letâ€™s go step by step on how you go from RTL code (good_mux.v) to a synthesized netlist using a tool like Yosys.
Step 1: Write RTL Code

Step 2: Prepare a Synthesis Script

Step 3: Choose a Target Library

Step 4: Run Synthesis
```
RTL Code â†’ Simulation â†’ Synthesis Script + Library â†’ Yosys â†’ Gate-Level Netlist 
```

ğŸ”€ What is a Multiplexer (MUX)?

A Multiplexer (MUX) is a combinational digital circuit that selects one of several input signals and forwards it to a single output line.

It acts like a digital switch.

The selection of which input is passed to the output is controlled by select (sel) lines.

# ğŸ’¡ Why is MUX important?

Used in processors (CPUs) to select data paths.

Helps in decision-making circuits.

Reduces hardware by allowing multiple inputs to share one output channel.

# ğŸ”§ Steps Taken

1. Created good_mux.v with RTL design.

2. Wrote a testbench tb_good_mux.v to apply different inputs and sel.

3. Compiled and ran the design using Icarus Verilog (iverilog).

4. Viewed output waveforms in GTKWave.

# What is RTL?

RTL (Register Transfer Level) is a way of describing digital circuits in terms of data flow between registers and the logic operations performed on that data.

RTL code
```
module good_mux (input i0 ,
 input i1 ,
input sel ,
output reg y);

always @ (*)
begin
	if(sel)
		y <= i1;
	else 
		y <= i0;
end
endmodule
```

ğŸ“ Explanation

Module Name: good_mux

Inputs:
```
i0 â†’ first data input

i1 â†’ second data input

sel â†’ selection line (control signal)
```
Output:
```
y â†’ output chosen based on sel
```
ğŸ”§ Logic:
```
If sel = 0, the output y = i0.

If sel = 1, the output y = i1.
```
This is the standard behavior of a 2-to-1 multiplexer (MUX), which acts like a switch to select one of two inputs.


# What is a Testbench (TB)?

A Testbench (TB) is a piece of code written in an HDL (like Verilog/SystemVerilog) that is not part of the final hardware but is used to verify the functionality of your design (DUT â€“ Device Under Test).

Testbench
```
`timescale 1ns / 1ps
module tb_good_mux;
	// Inputs
	reg i0,i1,sel;
	// Outputs
	wire y;

        // Instantiate the Unit Under Test (UUT)
	good_mux uut (
		.sel(sel),
		.i0(i0),
		.i1(i1),
		.y(y)
	);

	initial begin
	$dumpfile("tb_good_mux.vcd");
	$dumpvars(0,tb_good_mux);
	// Initialize Inputs
	sel = 0;
	i0 = 0;
	i1 = 0;
	#300 $finish;
	end

always #75 sel = ~sel;
always #10 i0 = ~i0;
always #55 i1 = ~i1;
endmodule
```
ğŸ“œ Commands Used
Compile the mux with testbench
  ```
iverilog -o good_mux_tb good_mux.v tb_good_mux.v
```
Run the simulation
  ```
./a.out good_mux_tb
```
Open the waveform in GTKWave
  ```
gtkwave dump.vcd
```
<img width="1920" height="909" alt="gtkwave good_mux" src="https://github.com/user-attachments/assets/aea8407d-b62e-4d26-97d5-b2816a9ddf72" />

âœ… Result
```
When sel = 0 â†’ y = i0

When sel = 1 â†’ y = i1
```
# Task 2 ğŸ“ Library

ğŸ“ What is Library?

In the context of digital design and Verilog, a library is essentially a collection of predefined components or modules that you can use in your design, instead of writing everything from scratch.

A library contains cells or modules like:

Logic gates: AND, OR, NAND, NOR

Flip-flops: DFF, TFF

Multiplexers, adders, decoders, etc.

These cells are usually optimized for a specific technology (like 130nm, 65nm) so that when you synthesize your design, the tool can map your logic efficiently to the real hardware.

```sky130_fd_sc_hd_mux2_1```is a library cell from the SkyWater 130nm standard cell library.

Yosys replaced your original Verilog good_mux logic with this optimized hardware implementation.

Why Libraries Are Useful

Time-saving â€“ You donâ€™t need to design gates manually.

Optimized â€“ The library cells are designed for area, speed, and power.

Technology-specific â€“ Makes it easier to target a real chip process.

# Task3 ğŸ› ï¸Synthesis

ğŸ› ï¸ What is Synthesis?

Synthesis is the process of converting your high-level Verilog code (RTL) into a gate-level netlist, which is a structural description of your circuit using basic logic gates. The output of this process is a new Verilog file that represents the synthesized circuit.

ğŸ“œ Commands Used

Read the Verilog design file
```
read_verilog good_mux.v
```
Perform generic synthesis steps
```
synth -top good_mux
```
Write the synthesized netlist to a new file
```
write_verilog good_mux_netlist.v
```
Generated by Yosys 0.9
```
module good_mux(i0, i1, sel, y);
  wire 0;
  wire 1;
  wire 2;
  wire 3;
  input i0;
  input i1;
  input sel;
  output y;
  sky130_fd_sc_hd_mux2_1 _4 (
    .A0(0),
    .A1(1),
    .S(2),
    .X(3)
  );
  assign 0 = i0;
  assign 1 = i1;
  assign 2 = sel;
  assign y = 3;
endmodule
```
Run 
```
show
```
<img width="1920" height="909" alt="Synthesis good_mux" src="https://github.com/user-attachments/assets/73ffdb7d-0de0-4ffc-a186-788b54c2a3de" />
